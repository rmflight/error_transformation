---
title: "Visualizing Effect of Data Transformations on Errors"
author: "Robert M Flight"
date: "`r Sys.time()`"
commit: "`r substr(git2r::branch_target(git2r::head(git2r::repository(getwd()))), 1, 8)`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(fakeDataWithError)
library(visualizationQualityControl)
library(cowplot)
library(dplyr)
```

```{r function_defs, include=FALSE}
#' plot differences in range
#' 
#' @param org_data the original data
#' @param log_mean should plot with log-transformed mean on x-axis?
plot_diff <- function(org_data, log_mean = log1p){

  # calculate the range between lowest and highest value of each feature
  diff_values <- apply(org_data, 1, function(x){max(x) - min(x)})
  diff_frame <- data.frame(diff = diff_values, mean = rowMeans(org_data))
  
  # how to label the x-axis
  use_mean <- "mean"
  x_title <- use_mean
  
  # if using log-mean, then transform
  if (is.function(log_mean)) {
    use_mean <- "log_mean"
    x_title <- "log(mean)"
    diff_frame <- mutate(diff_frame, log_mean = log1p(mean))
  }
  
  # generate and return the plot
  diff_plot <- ggplot(diff_frame, aes_string(x = use_mean, y = "diff")) + 
    geom_point() + ggtitle("Difference vs Mean") + xlab(x_title)
  return(diff_plot)
}

#' sd and rsd plot
#' 
#' @param org_data the original data as matrix
#' @param log_mean should the mean on x-axis be log-transformed
#' @param sd_type plot the SD or RSD?
plot_sd <- function(org_data, log_mean = log1p, sd_type = "sd"){
  # summarize the data
  summ_data <- summarize_data(t(org_data), log_transform = log_mean)
  
  # choose whether to transform the mean or not
  use_mean <- "mean"
  x_title <- use_mean
  
  if (is.function(log_mean)) {
    use_mean <- "log_mean"
    x_title <- "log(mean)"
  }
  
  # filter based on type of SD and plot
  sd_plot <- filter(summ_data, type == sd_type) %>% 
    ggplot(., aes_string(x = use_mean, y = "var")) + geom_point() +
    ggtitle("Mean vs SD") + xlab(x_title) + ylab(sd_type)
  return(sd_plot)
}

#' generate histogram
#' 
#' @param in_data original data
#' @param bins how many bins to use
plot_hist <- function(in_data, bins = 100){
  plot_frame <- data.frame(abundance = as.vector(in_data))
  ggplot(plot_frame, aes(x = abundance)) + geom_histogram(bins = bins)
}

#' root transform the data
#'
#' @param in_data data to transform
#' @param root what root to use in the transformation
root_transform <- function(in_data, root = 2){
  root_data <- in_data ^ (1/root)
  root_data
}

#' filter data
#'
#' @param in_data original input data
#' @param min_value what minimum value to filter out
filter_features <- function(in_data, min_value){
  n_rep <- ncol(in_data)
  pass_filter <- apply(in_data, 1, function(x){
    sum(x >= min_value) == n_rep
  })
  out_data <- in_data[pass_filter, ]
  out_data
}

#' apply auto scaling
#' 
#' auto scaling scales by subtracting the mean and dividing by the standard
#' deviation
#'
#' @param in_data the matrix of original data 
#' @param sub_mean should mean subtraction be performed
auto_scale <- function(in_data, sub_mean = FALSE){
  if (sub_mean) {
    out_val <- t(apply(in_data, 1, function(x){x - mean(x)}))
  } else {
    out_val <- in_data
  }
  
  out_val <- t(apply(out_val, 1, function(x){x / sd(x)}))
  out_val
}

#' apply pareto scaling
#' 
#' auto scaling scales by subtracting the mean and dividing by the standard
#' deviation
#'
#' @param in_data the matrix of original data 
#' @param sub_mean should mean subtraction be performed
pareto_scale <- function(in_data, sub_mean = FALSE){
  
  if (sub_mean) {
    out_val <- t(apply(in_data, 1, function(x){x - mean(x)}))
  } else {
    out_val <- in_data
  }
  
  out_val <- t(apply(out_val, 1, function(x){x / sqrt(sd(x))}))
  out_val
}
```


# Introduction

Various scalings and transformations are often applied to different -omics data
to modify specific properties of the data, these generally make the data more
amenable to various statistical procedures. Most common are modifications in the
error structure, often going from multiplicative errors that are commonly
present in any data generated by counts at a detector (essentially all
high-throughput -omics data) to additive errors, which most statistical methods
expect.

Previous work has examined the influence of scalings and transformations on both
the structure of the data and the errors through the use of replicated nuclear 
magnetic resonance (NMR) (REF) and coupled gas chromatography mass spectrometry
(GC-MS) experiments (REF). Although insightful, these works did not provide direct
control over the exact type and amount of error present in the data. Most of the discussion in previous work also concentrated on the shape of
the spectra after scaling and transformation. However, in many other -omics data
types outside of the metabolomics where NMR and GC-MS are applied, there is no
real spectra, but simply an aggregation of values measured on independent
features, and therefore changes in shape of the overall spectra are largely
irrelevant.

In the following, we demonstrate that the use of a simple summary of replicate 
experiments consisting of the **mean**, **maximum** - **minimum**, **standard
deviation** (sd), and **relative standard deviation** (rsd) is useful as a
visual indicator of the presence and type of errors in various -omics
datasets. A simple plot of both the **mean vs sd** and **mean vs rsd** is able
to determine whether the errors in an experiment are primarily **additive**
(random, constant, baseline error), **proportional** (dependent on the signal
value), or a **mixture**. From this visual summary, it is also possible to
evaluate the impact of different scalings and transformations on the error
structure in the data.

We evaluate the impact of the scalings and transformations through the use of 
synthetic data where specific amounts of **additive** and **proportional** error
have been added.

# Methods



## Data

```{r setup_data}
set.seed(1234)
n_point <- 10000
n_rep <- 100
offset <- 4
simulated_data <- c(rlnorm(n_point / 2, meanlog = 1, sdlog = 1),
                    runif(n_point / 2, 5, 100))
simulated_data <- simulated_data + offset
```

Simulated data was generated by drawing points from two different distributions:
1) log-normal distribution with a mean in log-space of 1 and a standard
deviation of 1 (see histogram in Figure X); 2) a uniform distribution over the
range of 5 - 100, with `r n_point/2` points in each distribution. A value of `r
offset` was added to the data purely to avoid values <= 1 following the addition
of error, making visualization easier. These data points are the **pure**
initial data to which different types of error are added. From this set, `r
n_rep` replicates are generated with either *additive* (`add`), *proportional*
(`prop`) or *mixed* (both additive and proportional, `mixed`) error.

```{r pure_histogram}
simulated_frame <- data.frame(abundance = simulated_data)
ggplot(simulated_frame, aes(x = abundance)) + geom_histogram(binwidth = 1) + 
  ggtitle("Pure Data")
```

### Additive Error

```{r add_error}
add_sd <- 0.5
add_error <- add_uniform_noise(n_rep, simulated_data, add_sd)
add_error[(add_error < 0)] <- 0

add_nozero <- filter_features(add_error, 1e-16)
add_minone <- filter_features(add_error, 1)
```

Additive error was added where the standard deviation was `r add_sd`. A plot
of two replicates is shown in Figure X.

### Proportional Error

```{r prop_error}
prop_sd <- 0.1
prop_error <- add_prop_noise(n_rep, simulated_data, prop_sd)
prop_error[(prop_error < 0)] <- 0

prop_nozero <- filter_features(prop_error, 1e-16)
prop_minone <- filter_features(prop_error, 1)
```

Proportional error was added with a relative standard deviation of `r prop_sd`. A
plot of two replicates is shown in Figure X.

### Mixed Error

```{r mix_error}
mix_error <- add_prop_uniform(n_rep, simulated_data, add_sd, prop_sd)
mix_error[(mix_error < 0)] <- 0

mix_nozero <- filter_features(mix_error, 1e-16)
mix_minone <- filter_features(mix_error, 1)
```

A mixture of additive and proportional errors was added using standard deviations
and relative standard deviations of `r add_sd` and `r prop_sd` respectively.


## Transformations

The transformations applied to the data include autoscaling, pareto scaling, 
log-transform (natural log), and power transform (using roots of 2 and 5).

# Results

Very often, high-throughput -omics replicates are visualized in a pairwise
manner, by plotting the replicates directly against each other, or rotating them
by 45 degrees as a Bland-Altman or MA plot (see Figure Xa and b). Overviews of
many replicate / samples can be provided by summarizing each pair by the
correlation or root mean squared error (RMSE), however neither of these provide
a way to view how or if errors are related to the value of a feature across all
replicates. The pairwise MA plot allows this for pairs, but examining a large
number of pairwise plots is tedious.

One simple extension is for each feature, to plot the difference between the
minimum and maximum value across replicates, vs the mean value, as shown in
Figure Xc. A more robust metric with essentially the same information is to plot the
standard deviation against the mean. This actually shows if there is
any relationship between the error (standard deviation) and the mean, which can
provide an indication of whether there is additive, or proportional errors
present. Adding a plot of the *relative standard deviation* (RSD, SD / mean) *vs the
mean* as well as *sd vs mean*  makes it possible to discern the presence of
additive, proportional, or mixed error ( see Figures X-Y for examples).

```{r buildup_plots}
pair_frame <- data.frame(rep1 = add_nozero[,1], rep2 = add_nozero[,2])
pair_plot <- ggplot(pair_frame, aes(x = rep1, y = rep2)) + geom_point()

ma_frame <- data.frame(M = add_nozero[,1] - add_nozero[,2],
                      A = rowMeans(add_nozero[, 1:2]))
ma_plot <- ggplot(ma_frame, aes(x = A, y = M)) + geom_point()

diff_nozero <- apply(add_nozero, 1, function(x){
  max(x) - min(x)
})
range_frame <- data.frame(difference = diff_nozero,
                          mean = rowMeans(add_nozero))
diff_plot <- ggplot(range_frame, aes(x = mean, y = difference)) + geom_point()

add_nozero_summ <- summarize_data(t(add_nozero))
sd_plot <- filter(add_nozero_summ, type == "sd") %>% 
  ggplot(., aes(x = mean, y = var)) + geom_point() + ylab("sd")
rsd_plot <- filter(add_nozero_summ, type == "rsd") %>%
  ggplot(., aes(x = mean, y = var)) + geom_point() + ylab("rsd")

plot_grid(pair_plot, ma_plot, diff_plot, sd_plot, rsd_plot, nrow = 1,
          labels = LETTERS[1:5])
```


## No Transformation

With no transformation, **all** of the data have a **log-normal** distribution.

```{r plot_dist_add}
plot_hist(add_nozero)
```


### Additive Error

```{r add_plot}
ae_nt_diff <- plot_diff(add_nozero)
ae_nt_sd <- plot_sd(add_nozero)
ae_nt_sd <- ae_nt_sd + geom_hline(yintercept = add_sd, color = "red")

ae_nt_rsd <- plot_sd(add_nozero, sd_type = "rsd")
plot_grid(ae_nt_diff, ae_nt_sd, ae_nt_rsd, nrow = 1, labels = LETTERS[1:3])
```

### Proportional Error

```{r prop_plot}
pe_nt_diff <- plot_diff(prop_nozero)
pe_nt_sd <- plot_sd(prop_nozero)

pe_nt_rsd <- plot_sd(prop_nozero, sd_type = "rsd") + 
  geom_hline(yintercept = prop_sd, color = "red")

plot_grid(pe_nt_diff, pe_nt_sd, pe_nt_rsd, nrow = 1, labels = LETTERS[1:3])
```

### Mixed Error

```{r mix_plot}
me_nt_diff <- plot_diff(mix_nozero)
me_nt_sd <- plot_sd(mix_nozero) + geom_hline(yintercept = add_sd, color = "red")
me_nt_rsd <- plot_sd(mix_nozero, sd_type = "rsd") + 
  geom_hline(yintercept = prop_sd, color = "red")

plot_grid(me_nt_diff, me_nt_sd, me_nt_rsd, nrow = 1, labels = LETTERS[1:3])
```

## Variance (Auto) Scaling

Applying a variance or auto scaling to the data results in:

### Additive

```{r auto_additive}
ae_as <- auto_scale(add_nozero)
ae_as_summary <- summarize_data(t(ae_as))
ae_as_diff <- plot_diff(ae_as, log_mean = log)
ae_as_sd <- plot_sd(ae_as, log_mean = log)
ae_as_rsd <- plot_sd(ae_as, sd_type = "rsd", log_mean = log)
plot_grid(ae_as_diff, ae_as_sd, ae_as_rsd, nrow = 1, labels = LETTERS[1:3])
```

### Proportional

```{r auto_proportional}
pe_as <- auto_scale(prop_nozero)
pe_as_diff <- plot_diff(pe_as, log_mean = log)
pe_as_sd <- plot_sd(pe_as, log_mean = log)
pe_as_rsd <- plot_sd(pe_as, sd_type = "rsd", log_mean = log)
plot_grid(pe_as_diff, pe_as_sd, pe_as_rsd, nrow = 1, labels = LETTERS[1:3])
```

### Mixed

```{r auto_mixed}
me_as <- auto_scale(mix_nozero)
me_as_diff <- plot_diff(me_as, log_mean = log)
me_as_sd <- plot_sd(me_as, log_mean = log)
me_as_rsd <- plot_sd(me_as, sd_type = "rsd", log_mean = log)
plot_grid(me_as_diff, me_as_sd, me_as_rsd, nrow = 1, labels = LETTERS[1:3])
```


## Pareto Scaling

### Additive

```{r pareto_add}
ae_ps <- pareto_scale(add_nozero)
ae_ps_diff <- plot_diff(ae_ps, log_mean = log)
ae_ps_sd <- plot_sd(ae_ps, log_mean = log)
ae_ps_rsd <- plot_sd(ae_ps, sd_type = "rsd", log_mean = log)
plot_grid(ae_ps_diff, ae_ps_sd, ae_ps_rsd, nrow = 1, labels = LETTERS[1:3])
```

### Proportional

```{r pareto_prop}
pe_ps <- pareto_scale(prop_nozero)
pe_ps_diff <- plot_diff(pe_ps, log_mean = log)
pe_ps_sd <- plot_sd(pe_ps, log_mean = log)
pe_ps_rsd <- plot_sd(pe_ps, sd_type = "rsd", log_mean = log)
plot_grid(pe_ps_diff, pe_ps_sd, pe_ps_rsd, nrow = 1, labels = LETTERS[1:3])
```

### Mixed

```{r pareto_mixed}
me_ps <- pareto_scale(mix_nozero)
me_ps_diff <- plot_diff(me_ps, log_mean = log)
me_ps_sd <- plot_sd(me_ps, log_mean = log)
me_ps_rsd <- plot_sd(me_ps, sd_type = "rsd", log_mean = log)
plot_grid(me_ps_diff, me_ps_sd, me_ps_rsd, nrow = 1, labels = LETTERS[1:3])
```


## Log Transformation

Applying the **log-transform** to the data results in:

```{r log_histogram}
log_add <- log(add_nozero)
plot_hist(log_add)
```

### Additive Error

```{r log_add_error}
ae_lt_diff <- plot_diff(log_add)
ae_lt_sd <- plot_sd(log_add)
ae_lt_rsd <- plot_sd(log_add, sd_type = "rsd")
plot_grid(ae_lt_diff, ae_lt_sd, ae_lt_rsd, nrow = 1, labels = LETTERS[1:3])
```

### Proportional Error

```{r log_prop_error}
log_prop <- log(prop_nozero)

pe_lt_diff <- plot_diff(log_prop, log_mean = FALSE)
pe_lt_sd <- plot_sd(log_prop, log_mean = FALSE)
pe_lt_rsd <- plot_sd(log_prop, log_mean = FALSE, sd_type = "rsd") + ylim(-1, 1)
plot_grid(pe_lt_diff, pe_lt_sd, pe_lt_rsd, nrow = 1, labels = LETTERS[1:3])
```

### Mixed Error

```{r log_mix_error}
log_mix <- log(mix_nozero)

me_lt_diff <- plot_diff(log_mix, log_mean = FALSE)
me_lt_sd <- plot_sd(log_mix, log_mean = FALSE)
me_lt_rsd <- plot_sd(log_mix, log_mean = FALSE, sd_type = "rsd")
plot_grid(me_lt_diff, me_lt_sd, me_lt_rsd, nrow = 1, labels = LETTERS[1:3])
```

## Root Transform

A square root transform was applied to the data. The choice of using 2 as the
root is arbitrary, however depending on the size of the **tails** of the data
a higher root may be useful. 

```{r root_histogram}

```

### Additive Error

```{r root_add_plot}
root_add <- root_transform(add_nozero)
root_add2 <- root_transform(add_nozero, 5)

root_add_comb <- cbind(root_add, root_add2)
root_class <- rep(c("2", "5"), each = 100)
root_summary <- summarize_data(t(root_add_comb), root_class)

ae_rt_diff <- filter(root_summary, type == "diff") %>%
  ggplot(., aes(x = mean, y = var, color = class)) + geom_point()
ae_rt_sd <- filter(root_summary, type == "sd") %>%
  ggplot(., aes(x = mean, y = var, color = class)) + geom_point()
ae_rt_rsd <- filter(root_summary, type == "rsd") %>%
  ggplot(., aes(x = mean, y = var, color = class)) + geom_point()
plot_grid(ae_rt_diff, ae_rt_sd, ae_rt_rsd, nrow = 1, labels = LETTERS[1:3])
```

### Proportional Error

```{r root_prop_plot}
root_prop1 <- root_transform(prop_nozero)
root_prop2 <- root_transform(prop_nozero, root = 5)
root_prop_comb <- cbind(root_prop1, root_prop2)

root_pe_summary <- summarize_data(t(root_prop_comb), root_class)

root_pe_diff <- filter(root_pe_summary, type == "diff") %>%
  ggplot(., aes(x = mean, y = var, color = class)) + geom_point()
root_pe_sd <- filter(root_pe_summary, type == "sd") %>%
  ggplot(., aes(x = mean, y = var, color = class)) + geom_point()
root_pe_rsd <- filter(root_pe_summary, type == "rsd") %>%
  ggplot(., aes(x = mean, y = var, color = class)) + geom_point()

plot_grid(root_pe_diff, root_pe_sd, root_pe_rsd, nrow = 1, labels = LETTERS[1:3])
```

### Mixed Error

```{r root_mixed_plot}
root_mixed <- root_transform(mix_nozero)
root_mixed2 <- root_transform(mix_nozero, 5)

me_rt_comb <- cbind(root_mixed, root_mixed2)

me_rt_summary <- summarize_data(t(me_rt_comb), root_class)
me_rt_diff <- filter(me_rt_summary, type == "diff") %>%
  ggplot(., aes(x = mean, y = var, color = class)) + geom_point()
me_rt_sd <- filter(me_rt_summary, type == "sd") %>%
  ggplot(., aes(x = mean, y = var, color = class)) + geom_point()
me_rt_rsd <- filter(me_rt_summary, type == "rsd") %>%
  ggplot(., aes(x = mean, y = var, color = class)) + geom_point()

plot_grid(me_rt_diff, me_rt_sd, me_rt_rsd, nrow = 1, labels = LETTERS[1:3])
```



# Conclusion


# Session Information

```{r session_info}
ses_info <- devtools::session_info()
ses_info$platform
knitr::kable(ses_info$packages, format = "markdown")
```


# Create Markdown

```{r runit, eval=FALSE, echo = TRUE}
rmarkdown::render("glbio2016_manuscript.Rmd", clean = FALSE)
```
