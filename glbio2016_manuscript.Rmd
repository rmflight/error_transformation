---
title: "Visualizing Effect of Data Transformations on Errors"
author: "Robert M Flight"
date: "`r Sys.time()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(fakeDataWithError)
library(visualizationQualityControl)
library(cowplot)
library(dplyr)
```

```{r function_defs, include=FALSE}
plot_function <- function(org_data, include_orgrep = TRUE, log_mean = TRUE){
  summ_data <- summarize_data(t(org_data))
  
  if (include_orgrep) {
    org_frame <- data.frame(rep1 = org_data[,1], rep2 = org_data[,2])
    org_plot <- ggplot(org_frame, aes(x = rep1, y = rep2)) + geom_point() +
      ggtitle("Rep1 vs Rep2")
  }
  
  use_mean <- "mean"
  x_title <- use_mean
  if (log_mean) {
    #summ_data[(summ_data$mean < 0), "mean"] <- 0
    summ_data <- mutate(summ_data, log_mean = log1p(mean))
    
    use_mean <- "log_mean"
    x_title <- "log(mean)"
  }
  
  sd_plot <- filter(summ_data, type == "sd") %>% 
    ggplot(., aes_string(x = use_mean, y = "var")) + geom_point() +
    ggtitle("Mean vs SD") + xlab(x_title) + ylab("sd")
  rsd_plot <- filter(summ_data, type == "rsd") %>%
    ggplot(., aes_string(x = use_mean, y = "var")) + geom_point() +
    ggtitle("Mean vs RSD") + xlab(x_title) + ylab("rsd")
  
  if (include_orgrep) {
    out_plot <- plot_grid(org_plot, sd_plot, rsd_plot, ncol = 3, nrow = 1,
              labels = c("A", "B", "C"))
  } else {
    out_plot <- plot_grid(sd_plot, rsd_plot, ncol = 2, nrow = 1, labels = c("A", "B"))
  }
  out_plot
}

add_small <- function(error_data, diff_value = 1e-2){
  min_notzero <- min(error_data[(error_data != 0)])
  add_min <- min_notzero * diff_value
  added_data <- error_data + add_min
  added_data
}

plot_hist <- function(in_data, bins = 100){
  plot_frame <- data.frame(abundance = as.vector(in_data))
  ggplot(plot_frame, aes(x = abundance)) + geom_histogram(bins = bins)
}

root_transform <- function(in_data, root = 2){
  root_data <- in_data ^ (1/root)
  root_data
}

filter_features <- function(in_data, min_value){
  n_rep <- ncol(in_data)
  pass_filter <- apply(in_data, 1, function(x){
    sum(x >= min_value) == n_rep
  })
  out_data <- in_data[pass_filter, ]
  out_data
}
```


# Introduction

Data transformations are frequently applied to different -omics data to change
properties of the data and make it more amenable to various statistical assumptions.
Included in the types of changes that are made include changing the error structure,
frequently from multiplicative errors that are commonly present in any data
generated by counts at a detector (essentially all -omics data) to additive errors,
which are more easily handled by most statistical methods.

We have previously used a simple summary of replicates consisting of the **mean**,
**standard deviation** (sd), and **relative standard deviation** (rsd) to evaluate
the presence of and type of errors in various -omics datasets. A simple plot of
both the **mean vs sd** and **mean vs rsd** is able to determine whether the
errors in an experiment are primarily **additive** (random, constant, baseline 
error), **proportional** (dependent on the signal value), or a **mixture**.

Previous work has examined the influence of transformations on both the structure
of the data and the errors through the use of replicated nuclear magnetic resonance
(NMR) experiments (REF). Although insightful, the exact types of errors were not
controlled, although they were likely similar to those simulated in this work.
Most of the discussion in previous work also concentrated on the shape of the
spectra after scaling and transformation. However, in many other -omics data
types outside of NMR, there is no real spectra, but simply an aggregation of
values measured on independent features, and therefore changes in shape of the
overall spectra are largely irrelevant. More importantly are whether relative
changes are preserved, and **how** the error structure changes.



# Methods



## Data

Simulated data was generated from an initial set of 10000 points drawn from 
a log-normal distribution with a mean in log-space of 1 and a standard deviation
of 1 (see histogram in Figure X). These data points are the **pure** initial 
data to which different types of error are added. From this set, 100 replicates are 
generated with either *additive* (`add`), *proportional* (`prop`) or *mixed* 
(both additive and proportional, `mixed`) error. Negative values are truncated 
to zero, because there cannot
be negative values when measuring the abundance of physical entities, and because
it makes applying log-transforms even more difficult than usual.

Alternatively, transformations and plots were applied to data where none of the
replicates have a zero value (`nozero`), or where none of the replicates were 
below **1** (`minone`). 

```{r setup_data}
set.seed(1234)
n_point <- 10000
n_rep <- 100
simulated_data <- rlnorm(n_point, meanlog = 1, sdlog = 1)
```

```{r pure_histogram}
simulated_frame <- data.frame(abundance = simulated_data)
ggplot(simulated_frame, aes(x = abundance)) + geom_histogram(binwidth = 1) + 
  ggtitle("Pure Data")
```

### Additive Error

```{r add_error}
add_sd <- 2
add_error <- add_uniform_noise(n_rep, simulated_data, add_sd)
add_error[(add_error < 0)] <- 0

add_nozero <- filter_features(add_error, 1e-16)
add_minone <- filter_features(add_error, 1)
```

Additive error was added where the standard deviation was `r add_sd`. A plot
of two replicates is shown in Figure X.

### Proportional Error

```{r prop_error}
prop_sd <- 0.1
prop_error <- add_prop_noise(n_rep, simulated_data, prop_sd)
prop_error[(prop_error < 0)] <- 0

prop_nozero <- filter_features(prop_error, 1e-16)
prop_minone <- filter_features(prop_error, 1)
```

Proportional error was added where the standard deviation was `r prop_sd`. A plot
of two replicates is shown in Figure X.

### Mixed Error

```{r mix_error}
mix_error <- add_prop_uniform(n_rep, simulated_data, add_sd, prop_sd)
mix_error[(mix_error < 0)] <- 0

mix_nozero <- filter_features(mix_error, 1e-16)
mix_minone <- filter_features(mix_error, 1)
```

Mixture of additive and proportional error was added with standard deviations
of `r add_sd` and `r prop_sd` respectively.

## Transformations

The transformations applied to the data include variance scaling, the log-transform
(log10), and power transform (root 2 and 5).

# Results

Very often, high-throughput -omics replicates are visualized in a pairwise manner,
by plotting the replicates directly against each other, or rotating them by 45 degrees
as a Bland-Altman or MA plot (see Figure Xa and b). Overviews of many replicate /
samples can be provided by summarizing each pair by the correlation or root mean
squared error (RMSE), however neither of these provide a way to view how or if
errors are related to the value of a feature across all replicates. The pairwise
MA plot allows this for pairs, but examining a large number of pairwise plots is
tedious. 

One simple extension is for each feature, to plot the difference between the minimum
and maximum value across replicates, vs the mean value, as shown in Figure Xc.
A more robust metric with much of the same meaning is to use the standard deviation,
plotted against the mean. This actually shows if there is any relationship between
the error (standard deviation) and the mean, which can provide an indication of
whether there is additive, or proportional errors present. Plotting the *relative
standard deviation* (RSD, SD / mean) *vs the mean* as well as *sd vs mean*  makes
it possible to discern the presence of additive, proportional, or mixed error (
see Figures X-Y for examples).

```{r buildup_plots}
pair_frame <- data.frame(rep1 = add_nozero[,1], rep2 = add_nozero[,2])
pair_plot <- ggplot(pair_frame, aes(x = rep1, y = rep2)) + geom_point()

ma_frame <- data.frame(M = add_nozero[,1] - add_nozero[,2],
                      A = rowMeans(add_nozero[, 1:2]))
ma_plot <- ggplot(ma_frame, aes(x = A, y = M)) + geom_point()

diff_nozero <- apply(add_nozero, 1, function(x){
  max(x) - min(x)
})
range_frame <- data.frame(difference = diff_nozero,
                          mean = rowMeans(add_nozero))
diff_plot <- ggplot(range_frame, aes(x = mean, y = difference)) + geom_point()

add_nozero_summ <- summarize_data(t(add_nozero))
sd_plot <- filter(add_nozero_summ, type == "sd") %>% 
  ggplot(., aes(x = mean, y = var)) + geom_point() + ylab("sd")
rsd_plot <- filter(add_nozero_summ, type == "rsd") %>%
  ggplot(., aes(x = mean, y = var)) + geom_point() + ylab("rsd")

plot_grid(pair_plot, ma_plot, diff_plot, sd_plot, rsd_plot, nrow = 1,
          labels = LETTERS[1:5])
```


## No Transformation

With no transformation, **all** of the data have a **log-normal** distribution.

```{r plot_dist_add}
plot_hist(add_nozero)
```


### Additive Error

```{r add_plot}
plot_function(add_nozero)
```

### Proportional Error

```{r prop_plot}
plot_function(prop_nozero)
```

### Mixed Error

```{r mix_plot}
plot_function(mix_nozero)
```

## Log Transformation

Applying the **log-transform** to the data results in:

```{r log_histogram}
log_add <- log10(add_nozero)
plot_hist(log_add)
```

### Additive Error

```{r log_add_error}
plot_function(log_add, log_mean = FALSE)
```

### Proportional Error

```{r log_prop_error}
log_prop <- log10(prop_nozero)
plot_function(log_prop, log_mean = FALSE)
```

### Mixed Error

```{r log_mix_error}
log_mix <- log10(mix_nozero)
plot_function(log_mix, log_mean = FALSE)
```

## Root Transform

A square root transform was applied to the data. The choice of using 2 as the
root is arbitrary, however depending on the size of the **tails** of the data
a higher root may be useful. 

```{r root_histogram}
root_add <- root_transform(add_nozero)
plot_hist(root_add)
```

### Additive Error

```{r root_add_plot}
plot_function(root_add)
```

### Proportional Error

```{r root_prop_plot}
root_prop <- root_transform(prop_nozero)
plot_function(root_prop)
```

### Mixed Error

```{r root_mixed_plot}
root_mixed <- root_transform(mix_nozero)
plot_function(root_mixed)
```



# Conclusion


# Session Information

```{r session_info}
ses_info <- devtools::session_info()
ses_info$platform
knitr::kable(ses_info$packages, format = "markdown")
```


# Create Markdown

```{r runit, eval=FALSE, include = TRUE}
rmarkdown::render("glbio2016_manuscript.Rmd", clean = FALSE)
```
